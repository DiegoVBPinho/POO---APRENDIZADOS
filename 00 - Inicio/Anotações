1. Um jeito de modelar o mundo no cÃ³digo

    Em vez de escrever um monte de funÃ§Ãµes soltas, vocÃª cria objetos que representam coisas: Pessoa, Carro, ContaBancÃ¡ria, Produto. Cada objeto tem:
    dados (atributos) â†’ caracterÃ­sticas
    comportamentos (mÃ©todos) â†’ o que ele pode fazer

2. Os pilares da POO

    Classe: o molde do objeto
    Ex: a classe Carro descreve que todo carro tem cor, ano e pode acelerar.

    Encapsulamento: proteger os dados
    Nem todo mundo deve mexer direto dentro do objeto. VocÃª controla o acesso.

    HeranÃ§a: reaproveitar estrutura
    Aluno pode herdar de Pessoa, ganhando atributos como nome e idade.

    Polimorfismo : mesmo mÃ©todo, comportamentos diferentes
    forma.desenhar() funciona para cÃ­rculo, quadrado, triÃ¢ngulo, cada um do seu jeito.

    AbstraÃ§Ã£o : focar no essencial
    Uma Conta nÃ£o precisa saber como o banco fÃ­sico funciona por trÃ¡s.

3. Por que isso Ã© diferente de â€œcÃ³digo rodandoâ€?

    VocÃª pode fazer em Java assim:
    tudo dentro do main
    vÃ¡rias variÃ¡veis soltas
    if gigante
    mÃ©todos estÃ¡ticos

    Vai funcionar?
    ğŸ‘‰ Vai.

    Ã‰ POO?
    ğŸ‘‰ NÃ£o.

    POO Ã© quando vocÃª sabe responder:

        Que classes existem no meu projeto?
        Quem Ã© responsÃ¡vel por cada regra?
        Como os objetos conversam entre si?
        Onde aplicar heranÃ§a de verdade e nÃ£o sÃ³ por aplicar?
        Como esconder implementaÃ§Ã£o e expor sÃ³ o necessÃ¡rio?